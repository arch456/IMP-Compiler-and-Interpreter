Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> block
Rule 5     stmt -> ID ASSIGN aexp ;
Rule 6     stmt -> INPUT ID ;
Rule 7     stmt -> PRINT exp ;
Rule 8     stmt -> IF ( bexp ) THEN block opt_else END
Rule 9     stmt -> WHILE ( bexp ) DO block END
Rule 10    opt_else -> ELSE block
Rule 11    opt_else -> empty
Rule 12    block -> { stmt_list }
Rule 13    block -> empty
Rule 14    exp -> ( exp )
Rule 15    exp -> aexp
Rule 16    exp -> bexp
Rule 17    bexp -> BOOL
Rule 18    bexp -> aexp EQ aexp
Rule 19    bexp -> aexp NE aexp
Rule 20    bexp -> aexp LT aexp
Rule 21    bexp -> aexp GT aexp
Rule 22    bexp -> aexp LE aexp
Rule 23    bexp -> aexp GE aexp
Rule 24    bexp -> NOT bexp
Rule 25    aexp -> INT
Rule 26    aexp -> ID
Rule 27    aexp -> aexp PLUS aexp
Rule 28    aexp -> aexp MINUS aexp
Rule 29    aexp -> aexp TIMES aexp
Rule 30    aexp -> aexp DIVIDE aexp
Rule 31    aexp -> MINUS aexp
Rule 32    empty -> <empty>

Terminals, with rules where they appear

(                    : 8 9 14
)                    : 8 9 14
;                    : 5 6 7
ASSIGN               : 5
BOOL                 : 17
DIVIDE               : 30
DO                   : 9
ELSE                 : 10
END                  : 8 9
EQ                   : 18
GE                   : 23
GT                   : 21
ID                   : 5 6 26
IF                   : 8
INPUT                : 6
INT                  : 25
LE                   : 22
LT                   : 20
MINUS                : 28 31
NE                   : 19
NOT                  : 24
PLUS                 : 27
PRINT                : 7
THEN                 : 8
TIMES                : 29
WHILE                : 9
error                : 
{                    : 12
}                    : 12

Nonterminals, with rules where they appear

aexp                 : 5 15 18 18 19 19 20 20 21 21 22 22 23 23 27 27 28 28 29 29 30 30 31
bexp                 : 8 9 16 24
block                : 4 8 9 10
empty                : 3 11 13
exp                  : 7 14
opt_else             : 8
program              : 0
stmt                 : 2
stmt_list            : 1 2 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . block
    (5) stmt -> . ID ASSIGN aexp ;
    (6) stmt -> . INPUT ID ;
    (7) stmt -> . PRINT exp ;
    (8) stmt -> . IF ( bexp ) THEN block opt_else END
    (9) stmt -> . WHILE ( bexp ) DO block END
    (32) empty -> .
    (12) block -> . { stmt_list }
    (13) block -> . empty

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for { resolved as shift
    ID              shift and go to state 6
    INPUT           shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    WHILE           shift and go to state 10
    $end            reduce using rule 32 (empty -> .)
    {               shift and go to state 11

  ! ID              [ reduce using rule 32 (empty -> .) ]
  ! INPUT           [ reduce using rule 32 (empty -> .) ]
  ! PRINT           [ reduce using rule 32 (empty -> .) ]
  ! IF              [ reduce using rule 32 (empty -> .) ]
  ! WHILE           [ reduce using rule 32 (empty -> .) ]
  ! {               [ reduce using rule 32 (empty -> .) ]

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    block                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . block
    (5) stmt -> . ID ASSIGN aexp ;
    (6) stmt -> . INPUT ID ;
    (7) stmt -> . PRINT exp ;
    (8) stmt -> . IF ( bexp ) THEN block opt_else END
    (9) stmt -> . WHILE ( bexp ) DO block END
    (32) empty -> .
    (12) block -> . { stmt_list }
    (13) block -> . empty

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for { resolved as shift
    ID              shift and go to state 6
    INPUT           shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    WHILE           shift and go to state 10
    $end            reduce using rule 32 (empty -> .)
    }               reduce using rule 32 (empty -> .)
    {               shift and go to state 11

  ! ID              [ reduce using rule 32 (empty -> .) ]
  ! INPUT           [ reduce using rule 32 (empty -> .) ]
  ! PRINT           [ reduce using rule 32 (empty -> .) ]
  ! IF              [ reduce using rule 32 (empty -> .) ]
  ! WHILE           [ reduce using rule 32 (empty -> .) ]
  ! {               [ reduce using rule 32 (empty -> .) ]

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 12
    empty                          shift and go to state 4
    block                          shift and go to state 5

state 4

    (3) stmt_list -> empty .
    (13) block -> empty .

  ! reduce/reduce conflict for $end resolved using rule 3 (stmt_list -> empty .)
  ! reduce/reduce conflict for } resolved using rule 3 (stmt_list -> empty .)
    $end            reduce using rule 3 (stmt_list -> empty .)
    }               reduce using rule 3 (stmt_list -> empty .)
    ID              reduce using rule 13 (block -> empty .)
    INPUT           reduce using rule 13 (block -> empty .)
    PRINT           reduce using rule 13 (block -> empty .)
    IF              reduce using rule 13 (block -> empty .)
    WHILE           reduce using rule 13 (block -> empty .)
    {               reduce using rule 13 (block -> empty .)

  ! $end            [ reduce using rule 13 (block -> empty .) ]
  ! }               [ reduce using rule 13 (block -> empty .) ]


state 5

    (4) stmt -> block .

    ID              reduce using rule 4 (stmt -> block .)
    INPUT           reduce using rule 4 (stmt -> block .)
    PRINT           reduce using rule 4 (stmt -> block .)
    IF              reduce using rule 4 (stmt -> block .)
    WHILE           reduce using rule 4 (stmt -> block .)
    {               reduce using rule 4 (stmt -> block .)
    $end            reduce using rule 4 (stmt -> block .)
    }               reduce using rule 4 (stmt -> block .)


state 6

    (5) stmt -> ID . ASSIGN aexp ;

    ASSIGN          shift and go to state 13


state 7

    (6) stmt -> INPUT . ID ;

    ID              shift and go to state 14


state 8

    (7) stmt -> PRINT . exp ;
    (14) exp -> . ( exp )
    (15) exp -> . aexp
    (16) exp -> . bexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp
    (17) bexp -> . BOOL
    (18) bexp -> . aexp EQ aexp
    (19) bexp -> . aexp NE aexp
    (20) bexp -> . aexp LT aexp
    (21) bexp -> . aexp GT aexp
    (22) bexp -> . aexp LE aexp
    (23) bexp -> . aexp GE aexp
    (24) bexp -> . NOT bexp

    (               shift and go to state 16
    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21
    BOOL            shift and go to state 22
    NOT             shift and go to state 23

    exp                            shift and go to state 15
    aexp                           shift and go to state 17
    bexp                           shift and go to state 18

state 9

    (8) stmt -> IF . ( bexp ) THEN block opt_else END

    (               shift and go to state 24


state 10

    (9) stmt -> WHILE . ( bexp ) DO block END

    (               shift and go to state 25


state 11

    (12) block -> { . stmt_list }
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . block
    (5) stmt -> . ID ASSIGN aexp ;
    (6) stmt -> . INPUT ID ;
    (7) stmt -> . PRINT exp ;
    (8) stmt -> . IF ( bexp ) THEN block opt_else END
    (9) stmt -> . WHILE ( bexp ) DO block END
    (32) empty -> .
    (12) block -> . { stmt_list }
    (13) block -> . empty

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for { resolved as shift
    ID              shift and go to state 6
    INPUT           shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    WHILE           shift and go to state 10
    }               reduce using rule 32 (empty -> .)
    {               shift and go to state 11

  ! ID              [ reduce using rule 32 (empty -> .) ]
  ! INPUT           [ reduce using rule 32 (empty -> .) ]
  ! PRINT           [ reduce using rule 32 (empty -> .) ]
  ! IF              [ reduce using rule 32 (empty -> .) ]
  ! WHILE           [ reduce using rule 32 (empty -> .) ]
  ! {               [ reduce using rule 32 (empty -> .) ]

    stmt_list                      shift and go to state 26
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    block                          shift and go to state 5

state 12

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    }               reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 13

    (5) stmt -> ID ASSIGN . aexp ;
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 27

state 14

    (6) stmt -> INPUT ID . ;

    ;               shift and go to state 28


state 15

    (7) stmt -> PRINT exp . ;

    ;               shift and go to state 29


state 16

    (14) exp -> ( . exp )
    (14) exp -> . ( exp )
    (15) exp -> . aexp
    (16) exp -> . bexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp
    (17) bexp -> . BOOL
    (18) bexp -> . aexp EQ aexp
    (19) bexp -> . aexp NE aexp
    (20) bexp -> . aexp LT aexp
    (21) bexp -> . aexp GT aexp
    (22) bexp -> . aexp LE aexp
    (23) bexp -> . aexp GE aexp
    (24) bexp -> . NOT bexp

    (               shift and go to state 16
    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21
    BOOL            shift and go to state 22
    NOT             shift and go to state 23

    exp                            shift and go to state 30
    aexp                           shift and go to state 17
    bexp                           shift and go to state 18

state 17

    (15) exp -> aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp
    (18) bexp -> aexp . EQ aexp
    (19) bexp -> aexp . NE aexp
    (20) bexp -> aexp . LT aexp
    (21) bexp -> aexp . GT aexp
    (22) bexp -> aexp . LE aexp
    (23) bexp -> aexp . GE aexp

    ;               reduce using rule 15 (exp -> aexp .)
    )               reduce using rule 15 (exp -> aexp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    EQ              shift and go to state 35
    NE              shift and go to state 36
    LT              shift and go to state 37
    GT              shift and go to state 38
    LE              shift and go to state 39
    GE              shift and go to state 40


state 18

    (16) exp -> bexp .

    ;               reduce using rule 16 (exp -> bexp .)
    )               reduce using rule 16 (exp -> bexp .)


state 19

    (25) aexp -> INT .

    PLUS            reduce using rule 25 (aexp -> INT .)
    MINUS           reduce using rule 25 (aexp -> INT .)
    TIMES           reduce using rule 25 (aexp -> INT .)
    DIVIDE          reduce using rule 25 (aexp -> INT .)
    EQ              reduce using rule 25 (aexp -> INT .)
    NE              reduce using rule 25 (aexp -> INT .)
    LT              reduce using rule 25 (aexp -> INT .)
    GT              reduce using rule 25 (aexp -> INT .)
    LE              reduce using rule 25 (aexp -> INT .)
    GE              reduce using rule 25 (aexp -> INT .)
    ;               reduce using rule 25 (aexp -> INT .)
    )               reduce using rule 25 (aexp -> INT .)


state 20

    (26) aexp -> ID .

    PLUS            reduce using rule 26 (aexp -> ID .)
    MINUS           reduce using rule 26 (aexp -> ID .)
    TIMES           reduce using rule 26 (aexp -> ID .)
    DIVIDE          reduce using rule 26 (aexp -> ID .)
    EQ              reduce using rule 26 (aexp -> ID .)
    NE              reduce using rule 26 (aexp -> ID .)
    LT              reduce using rule 26 (aexp -> ID .)
    GT              reduce using rule 26 (aexp -> ID .)
    LE              reduce using rule 26 (aexp -> ID .)
    GE              reduce using rule 26 (aexp -> ID .)
    ;               reduce using rule 26 (aexp -> ID .)
    )               reduce using rule 26 (aexp -> ID .)


state 21

    (31) aexp -> MINUS . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 41

state 22

    (17) bexp -> BOOL .

    ;               reduce using rule 17 (bexp -> BOOL .)
    )               reduce using rule 17 (bexp -> BOOL .)


state 23

    (24) bexp -> NOT . bexp
    (17) bexp -> . BOOL
    (18) bexp -> . aexp EQ aexp
    (19) bexp -> . aexp NE aexp
    (20) bexp -> . aexp LT aexp
    (21) bexp -> . aexp GT aexp
    (22) bexp -> . aexp LE aexp
    (23) bexp -> . aexp GE aexp
    (24) bexp -> . NOT bexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    BOOL            shift and go to state 22
    NOT             shift and go to state 23
    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    bexp                           shift and go to state 42
    aexp                           shift and go to state 43

state 24

    (8) stmt -> IF ( . bexp ) THEN block opt_else END
    (17) bexp -> . BOOL
    (18) bexp -> . aexp EQ aexp
    (19) bexp -> . aexp NE aexp
    (20) bexp -> . aexp LT aexp
    (21) bexp -> . aexp GT aexp
    (22) bexp -> . aexp LE aexp
    (23) bexp -> . aexp GE aexp
    (24) bexp -> . NOT bexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    BOOL            shift and go to state 22
    NOT             shift and go to state 23
    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    bexp                           shift and go to state 44
    aexp                           shift and go to state 43

state 25

    (9) stmt -> WHILE ( . bexp ) DO block END
    (17) bexp -> . BOOL
    (18) bexp -> . aexp EQ aexp
    (19) bexp -> . aexp NE aexp
    (20) bexp -> . aexp LT aexp
    (21) bexp -> . aexp GT aexp
    (22) bexp -> . aexp LE aexp
    (23) bexp -> . aexp GE aexp
    (24) bexp -> . NOT bexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    BOOL            shift and go to state 22
    NOT             shift and go to state 23
    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    bexp                           shift and go to state 45
    aexp                           shift and go to state 43

state 26

    (12) block -> { stmt_list . }

    }               shift and go to state 46


state 27

    (5) stmt -> ID ASSIGN aexp . ;
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    ;               shift and go to state 47
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 28

    (6) stmt -> INPUT ID ; .

    ID              reduce using rule 6 (stmt -> INPUT ID ; .)
    INPUT           reduce using rule 6 (stmt -> INPUT ID ; .)
    PRINT           reduce using rule 6 (stmt -> INPUT ID ; .)
    IF              reduce using rule 6 (stmt -> INPUT ID ; .)
    WHILE           reduce using rule 6 (stmt -> INPUT ID ; .)
    {               reduce using rule 6 (stmt -> INPUT ID ; .)
    $end            reduce using rule 6 (stmt -> INPUT ID ; .)
    }               reduce using rule 6 (stmt -> INPUT ID ; .)


state 29

    (7) stmt -> PRINT exp ; .

    ID              reduce using rule 7 (stmt -> PRINT exp ; .)
    INPUT           reduce using rule 7 (stmt -> PRINT exp ; .)
    PRINT           reduce using rule 7 (stmt -> PRINT exp ; .)
    IF              reduce using rule 7 (stmt -> PRINT exp ; .)
    WHILE           reduce using rule 7 (stmt -> PRINT exp ; .)
    {               reduce using rule 7 (stmt -> PRINT exp ; .)
    $end            reduce using rule 7 (stmt -> PRINT exp ; .)
    }               reduce using rule 7 (stmt -> PRINT exp ; .)


state 30

    (14) exp -> ( exp . )

    )               shift and go to state 48


state 31

    (27) aexp -> aexp PLUS . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 49

state 32

    (28) aexp -> aexp MINUS . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 50

state 33

    (29) aexp -> aexp TIMES . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 51

state 34

    (30) aexp -> aexp DIVIDE . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 52

state 35

    (18) bexp -> aexp EQ . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 53

state 36

    (19) bexp -> aexp NE . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 54

state 37

    (20) bexp -> aexp LT . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 55

state 38

    (21) bexp -> aexp GT . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 56

state 39

    (22) bexp -> aexp LE . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 57

state 40

    (23) bexp -> aexp GE . aexp
    (25) aexp -> . INT
    (26) aexp -> . ID
    (27) aexp -> . aexp PLUS aexp
    (28) aexp -> . aexp MINUS aexp
    (29) aexp -> . aexp TIMES aexp
    (30) aexp -> . aexp DIVIDE aexp
    (31) aexp -> . MINUS aexp

    INT             shift and go to state 19
    ID              shift and go to state 20
    MINUS           shift and go to state 21

    aexp                           shift and go to state 58

state 41

    (31) aexp -> MINUS aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    PLUS            reduce using rule 31 (aexp -> MINUS aexp .)
    MINUS           reduce using rule 31 (aexp -> MINUS aexp .)
    TIMES           reduce using rule 31 (aexp -> MINUS aexp .)
    DIVIDE          reduce using rule 31 (aexp -> MINUS aexp .)
    EQ              reduce using rule 31 (aexp -> MINUS aexp .)
    NE              reduce using rule 31 (aexp -> MINUS aexp .)
    LT              reduce using rule 31 (aexp -> MINUS aexp .)
    GT              reduce using rule 31 (aexp -> MINUS aexp .)
    LE              reduce using rule 31 (aexp -> MINUS aexp .)
    GE              reduce using rule 31 (aexp -> MINUS aexp .)
    ;               reduce using rule 31 (aexp -> MINUS aexp .)
    )               reduce using rule 31 (aexp -> MINUS aexp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! TIMES           [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]


state 42

    (24) bexp -> NOT bexp .

    ;               reduce using rule 24 (bexp -> NOT bexp .)
    )               reduce using rule 24 (bexp -> NOT bexp .)


state 43

    (18) bexp -> aexp . EQ aexp
    (19) bexp -> aexp . NE aexp
    (20) bexp -> aexp . LT aexp
    (21) bexp -> aexp . GT aexp
    (22) bexp -> aexp . LE aexp
    (23) bexp -> aexp . GE aexp
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    EQ              shift and go to state 35
    NE              shift and go to state 36
    LT              shift and go to state 37
    GT              shift and go to state 38
    LE              shift and go to state 39
    GE              shift and go to state 40
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 44

    (8) stmt -> IF ( bexp . ) THEN block opt_else END

    )               shift and go to state 59


state 45

    (9) stmt -> WHILE ( bexp . ) DO block END

    )               shift and go to state 60


state 46

    (12) block -> { stmt_list } .

    ID              reduce using rule 12 (block -> { stmt_list } .)
    INPUT           reduce using rule 12 (block -> { stmt_list } .)
    PRINT           reduce using rule 12 (block -> { stmt_list } .)
    IF              reduce using rule 12 (block -> { stmt_list } .)
    WHILE           reduce using rule 12 (block -> { stmt_list } .)
    {               reduce using rule 12 (block -> { stmt_list } .)
    $end            reduce using rule 12 (block -> { stmt_list } .)
    }               reduce using rule 12 (block -> { stmt_list } .)
    ELSE            reduce using rule 12 (block -> { stmt_list } .)
    END             reduce using rule 12 (block -> { stmt_list } .)


state 47

    (5) stmt -> ID ASSIGN aexp ; .

    ID              reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)
    INPUT           reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)
    PRINT           reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)
    IF              reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)
    WHILE           reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)
    {               reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)
    $end            reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)
    }               reduce using rule 5 (stmt -> ID ASSIGN aexp ; .)


state 48

    (14) exp -> ( exp ) .

    ;               reduce using rule 14 (exp -> ( exp ) .)
    )               reduce using rule 14 (exp -> ( exp ) .)


state 49

    (27) aexp -> aexp PLUS aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    PLUS            reduce using rule 27 (aexp -> aexp PLUS aexp .)
    MINUS           reduce using rule 27 (aexp -> aexp PLUS aexp .)
    EQ              reduce using rule 27 (aexp -> aexp PLUS aexp .)
    NE              reduce using rule 27 (aexp -> aexp PLUS aexp .)
    LT              reduce using rule 27 (aexp -> aexp PLUS aexp .)
    GT              reduce using rule 27 (aexp -> aexp PLUS aexp .)
    LE              reduce using rule 27 (aexp -> aexp PLUS aexp .)
    GE              reduce using rule 27 (aexp -> aexp PLUS aexp .)
    ;               reduce using rule 27 (aexp -> aexp PLUS aexp .)
    )               reduce using rule 27 (aexp -> aexp PLUS aexp .)
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34

  ! TIMES           [ reduce using rule 27 (aexp -> aexp PLUS aexp .) ]
  ! DIVIDE          [ reduce using rule 27 (aexp -> aexp PLUS aexp .) ]
  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]


state 50

    (28) aexp -> aexp MINUS aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    PLUS            reduce using rule 28 (aexp -> aexp MINUS aexp .)
    MINUS           reduce using rule 28 (aexp -> aexp MINUS aexp .)
    EQ              reduce using rule 28 (aexp -> aexp MINUS aexp .)
    NE              reduce using rule 28 (aexp -> aexp MINUS aexp .)
    LT              reduce using rule 28 (aexp -> aexp MINUS aexp .)
    GT              reduce using rule 28 (aexp -> aexp MINUS aexp .)
    LE              reduce using rule 28 (aexp -> aexp MINUS aexp .)
    GE              reduce using rule 28 (aexp -> aexp MINUS aexp .)
    ;               reduce using rule 28 (aexp -> aexp MINUS aexp .)
    )               reduce using rule 28 (aexp -> aexp MINUS aexp .)
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34

  ! TIMES           [ reduce using rule 28 (aexp -> aexp MINUS aexp .) ]
  ! DIVIDE          [ reduce using rule 28 (aexp -> aexp MINUS aexp .) ]
  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]


state 51

    (29) aexp -> aexp TIMES aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    PLUS            reduce using rule 29 (aexp -> aexp TIMES aexp .)
    MINUS           reduce using rule 29 (aexp -> aexp TIMES aexp .)
    TIMES           reduce using rule 29 (aexp -> aexp TIMES aexp .)
    DIVIDE          reduce using rule 29 (aexp -> aexp TIMES aexp .)
    EQ              reduce using rule 29 (aexp -> aexp TIMES aexp .)
    NE              reduce using rule 29 (aexp -> aexp TIMES aexp .)
    LT              reduce using rule 29 (aexp -> aexp TIMES aexp .)
    GT              reduce using rule 29 (aexp -> aexp TIMES aexp .)
    LE              reduce using rule 29 (aexp -> aexp TIMES aexp .)
    GE              reduce using rule 29 (aexp -> aexp TIMES aexp .)
    ;               reduce using rule 29 (aexp -> aexp TIMES aexp .)
    )               reduce using rule 29 (aexp -> aexp TIMES aexp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! TIMES           [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]


state 52

    (30) aexp -> aexp DIVIDE aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    PLUS            reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    MINUS           reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    TIMES           reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    DIVIDE          reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    EQ              reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    NE              reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    LT              reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    GT              reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    LE              reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    GE              reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    ;               reduce using rule 30 (aexp -> aexp DIVIDE aexp .)
    )               reduce using rule 30 (aexp -> aexp DIVIDE aexp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! TIMES           [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]


state 53

    (18) bexp -> aexp EQ aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    ;               reduce using rule 18 (bexp -> aexp EQ aexp .)
    )               reduce using rule 18 (bexp -> aexp EQ aexp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 54

    (19) bexp -> aexp NE aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    ;               reduce using rule 19 (bexp -> aexp NE aexp .)
    )               reduce using rule 19 (bexp -> aexp NE aexp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 55

    (20) bexp -> aexp LT aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    ;               reduce using rule 20 (bexp -> aexp LT aexp .)
    )               reduce using rule 20 (bexp -> aexp LT aexp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 56

    (21) bexp -> aexp GT aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    ;               reduce using rule 21 (bexp -> aexp GT aexp .)
    )               reduce using rule 21 (bexp -> aexp GT aexp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 57

    (22) bexp -> aexp LE aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    ;               reduce using rule 22 (bexp -> aexp LE aexp .)
    )               reduce using rule 22 (bexp -> aexp LE aexp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 58

    (23) bexp -> aexp GE aexp .
    (27) aexp -> aexp . PLUS aexp
    (28) aexp -> aexp . MINUS aexp
    (29) aexp -> aexp . TIMES aexp
    (30) aexp -> aexp . DIVIDE aexp

    ;               reduce using rule 23 (bexp -> aexp GE aexp .)
    )               reduce using rule 23 (bexp -> aexp GE aexp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34


state 59

    (8) stmt -> IF ( bexp ) . THEN block opt_else END

    THEN            shift and go to state 61


state 60

    (9) stmt -> WHILE ( bexp ) . DO block END

    DO              shift and go to state 62


state 61

    (8) stmt -> IF ( bexp ) THEN . block opt_else END
    (12) block -> . { stmt_list }
    (13) block -> . empty
    (32) empty -> .

    {               shift and go to state 11
    ELSE            reduce using rule 32 (empty -> .)
    END             reduce using rule 32 (empty -> .)

    block                          shift and go to state 63
    empty                          shift and go to state 64

state 62

    (9) stmt -> WHILE ( bexp ) DO . block END
    (12) block -> . { stmt_list }
    (13) block -> . empty
    (32) empty -> .

    {               shift and go to state 11
    END             reduce using rule 32 (empty -> .)

    block                          shift and go to state 65
    empty                          shift and go to state 64

state 63

    (8) stmt -> IF ( bexp ) THEN block . opt_else END
    (10) opt_else -> . ELSE block
    (11) opt_else -> . empty
    (32) empty -> .

    ELSE            shift and go to state 67
    END             reduce using rule 32 (empty -> .)

    opt_else                       shift and go to state 66
    empty                          shift and go to state 68

state 64

    (13) block -> empty .

    ELSE            reduce using rule 13 (block -> empty .)
    END             reduce using rule 13 (block -> empty .)


state 65

    (9) stmt -> WHILE ( bexp ) DO block . END

    END             shift and go to state 69


state 66

    (8) stmt -> IF ( bexp ) THEN block opt_else . END

    END             shift and go to state 70


state 67

    (10) opt_else -> ELSE . block
    (12) block -> . { stmt_list }
    (13) block -> . empty
    (32) empty -> .

    {               shift and go to state 11
    END             reduce using rule 32 (empty -> .)

    block                          shift and go to state 71
    empty                          shift and go to state 64

state 68

    (11) opt_else -> empty .

    END             reduce using rule 11 (opt_else -> empty .)


state 69

    (9) stmt -> WHILE ( bexp ) DO block END .

    ID              reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)
    INPUT           reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)
    PRINT           reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)
    IF              reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)
    WHILE           reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)
    {               reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)
    $end            reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)
    }               reduce using rule 9 (stmt -> WHILE ( bexp ) DO block END .)


state 70

    (8) stmt -> IF ( bexp ) THEN block opt_else END .

    ID              reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)
    INPUT           reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)
    PRINT           reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)
    IF              reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)
    WHILE           reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)
    {               reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)
    $end            reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)
    }               reduce using rule 8 (stmt -> IF ( bexp ) THEN block opt_else END .)


state 71

    (10) opt_else -> ELSE block .

    END             reduce using rule 10 (opt_else -> ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for { in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 3 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for { in state 3 resolved as shift
WARNING: shift/reduce conflict for ID in state 11 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 11 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 11 resolved as shift
WARNING: shift/reduce conflict for IF in state 11 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 11 resolved as shift
WARNING: shift/reduce conflict for { in state 11 resolved as shift
WARNING: reduce/reduce conflict in state 4 resolved using rule (stmt_list -> empty)
WARNING: rejected rule (block -> empty) in state 4
